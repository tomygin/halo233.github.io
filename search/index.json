[{"content":" 记住爬虫的核心不是如何去下载数据，而是如何对下载的数据进行解析\n 准备 你首先需要知道goquery的基本选择语法 goquery选择器介绍\n安装goquery\ngo get github.com/PuerkitoBio/goquery由于使用了七牛云的代理，下载还是蛮快的\n导入goquery\nimport \u0026quot;github.com/PuerkitoBio/goquery\u0026quot;\n还需要一个gbk转utf-8的包\ngolang.org/x/net/html/charset\n爬取的思路是 Get第一页得到到返回体 =》如果不是utf-8就转码为utf-8\n=》利用goquery选着到需要的内容和下一个网页的链接\n=》保存内容如果有下一页的 url 再Get下一页\n爬取的网站 因为是刚入手，所以选择的是简单网站（没有反扒机制的网站）\n刚好自己又喜欢紫罗兰，又刚好找到了这么个小说网站 https://www.wenku8.net/novel/2/2353/\n注：本次爬取是静态网站，动态的博主还没有学习\ngoquery选择器 这个选择器和以前很出名的jquery如出一辙，是go版本的选择器\n其中基本选择模板为\n1 2 3 4 5 6  dom.Find(\u0026#34;条件\u0026#34;).Each(func(i int, r *goquery.Selection) { //选择属性的值 \tnext = r.AttrOr(\u0026#34;href\u0026#34;, \u0026#34;\u0026#34;) //选择文本内容  next = r.Text() })   由于引用文章写得足够详细，这里就不再累述\n写入文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //写入到文件 func WR(s string) { //创建一个新文件，写入内容 \tfilePath := \u0026#34;./output.txt\u0026#34; file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Printf(\u0026#34;打开文件错误= %v \\n\u0026#34;, err) return } //及时关闭 \tdefer file.Close() //写入内容 \t// txt文件要看到换行效果要用 \\r\\n \t//写入时，使用带缓存的 *Writer \twriter := bufio.NewWriter(file) writer.WriteString(s) //因为 writer 是带缓存的，因此在调用 WriterString 方法时，内容是先写入缓存的 \t//所以要调用 flush方法，将缓存的数据真正写入到文件中。 \twriter.Flush() }    引用文章：\ngoquery选择器介绍\ngoquery选择器的简单使用\n小游大佬的colly入门\n","date":"2022-03-06T00:00:00Z","permalink":"https://halo233.github.io/p/go%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC0%E7%AF%87/","title":"GO爬虫学习笔记第0篇"},{"content":"基础类型的申明 GO声明后自动初始化\n导出性原则 首字母大写\ntype 定义自己的类型\ntype IZ int\n类型拷贝\ntype IZ = int\n类型转换 typeB(typeA)\nmake和new的区别 new new返回一个指向类型为 T，值为 0 的地址的指针\nvar p *[]int = new([]int)\n// *p == nil\n// with len and cap 0\np := new([]int)\nnew 和 \u0026amp;type 的不同处 new初始化的值为默认值，不支持自定义的值\n\u0026amp;type初始化可以是自定义的值\nnew和\u0026amp;type的相同之处 返回的都是指针\nmake make 返回一个类型为 T 的初始值\nvar v []int = make([]int, 10, 50)\nv := make([]int, 10, 50)\nmake: 用于slice，map，和channel的初始化\n 引用文章\n 常量 换行 const text =\n0.368236\\ //常量换行不结束\n639852\niota const (\na = iota\n//\ta = 0 iota遇到const重置为0\nb\n//\tb = 1\nc\n//\tc = 2\n)\n变量 var 变量适合于全局变量\n整形 go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。\n如果是64位操作系统，int类型的大小就是8个字节\n一般情况 普通声明初始化\nvar name type\n赋值\nname = value\n自定义声明初始化\nvar name type = value\n编译器推断声明初始化\nvar name = value\n简短声明初始化，实用于局部变量\nname := value\n字符类型 byte是uint 8的别名\n自定义声明初始化\nvar ch byte = \u0026lsquo;A\u0026rsquo;\nrune 是int32的别名\n复数 complex 64\t其中虚部实部为\tfloat 32\ncomplex128 其中虚部实部为\tfloat 64\n普通声明初始化\nvar name complex128\n赋值\nname = complex (x, y)\nname = 888 + 999 i\n自定义声明初始化\nvar name complex128 = complex(x, y)\n简短声明初始化\nname := complex(x, y)\nname := 888 +666i\n获取实部 real(name)\n过去虚部 imag(name)\n指针变量 一般声明初始化\nvar intpr *int\n赋值\nintpr = \u0026amp;n\n自定义声明初始化\nvar intpr *int = \u0026amp;n\n简短声明初始化\np := \u0026amp;n\n数组 一般声明初始化\nvar arr [len]type\n赋值\narr[i] = value\n自定义声明\nvar arr = [5]int{1 8, 20, 15, 22, 16}\n编译器推断声明初始化\nvar arr = [\u0026hellip;]int{ 5, 6, 7, 8, 22}\n部分自定义声明初始化\nvar arr = [5]int{3: 222, 4: 999}\n简短声明初始化\na := [\u0026hellip;]int{222，444，555，999}\n切片 声明\nvar slice1 []type\n赋值\nslice1 []type = arr1[start:end]\nslice1 = \u0026amp;arr1\nslice1 = slicex[a :b]\n// 不包含b但是包含a，切片元素个数为b-a\n一般声明初始化\nvar slice1 []type = arr1[start:end]\nslice1 := make([]type, start_length, capacity)\n追加\nslice1 = append(slice1, slice2\u0026hellip;)\n字典 声明\nvar map1 map[keytype]valuetype\n初始化\nmap1 = map[string]int{\u0026ldquo;one\u0026rdquo;: 1, \u0026ldquo;two\u0026rdquo;: 2}\nmap1 = map[string]int{}\n//初始化一个空字典\n自定义声明初始化\nvar map1 map[string]int = map[string]int{\u0026ldquo;hunter\u0026rdquo;:12,\u0026ldquo;tony\u0026rdquo;:10}\n推断声明初始化\nvar map1 = map[string]int{\u0026ldquo;one\u0026rdquo;: 1, \u0026ldquo;two\u0026rdquo;: 2}\n简短声明初始化\nmap1 = map[string]int{\u0026ldquo;one\u0026rdquo;: 1, \u0026ldquo;two\u0026rdquo;: 2}\nmake声明初始化\nmapHaiCoder := make(map[string]string, 3)\n//3是容量\n超出容量时会自动扩容，但尽量提供一个合理的初始值\n赋值\nmap1[key1] = val1\n读取\nv := map1[key1]\n删除\ndelete(map1,kay)\n结构体 定义一个自己的结构体\ntype T struct {\nfield1 type1\nfield2 type2\n\u0026hellip;\n}\n声明自己的结构体\nvar s T\n结构体初始化\ns = struct1{10, 15.5, \u0026ldquo;Chris\u0026rdquo;}\n修改结构体内部字段\ns.a = 5\ns.b = 8\n结构体指针 \u0026amp;struct1{a, b, c} 是一种简写，底层仍然会调用 new ()\n结构体内嵌结构体 type innerS struct {\nin1 int\nin2 int\n}\ntype outerS struct {\nb int\nc float32\n// anonymous field\nint\n//anonymous field\ninnerS\n}\nfunc main() {\nouter := new(outerS)\nouter.b = 6\nouter.c = 7.5\nouter.in1 = 5\nouter.in2 = 1\n}\n结构体命名冲突 type A struct {a int}\ntype B struct {a, b int}\ntype C struct {A; B}\nvar c C\n报错\tc.a，编译器不知道是A中的还是B中的\n正确 c.A.a\n接口 接口是一种类型，它规定了变量有哪些方法\n定义一个接口类型\ntype name interface{\nFuncName(arg)return\nxxx\n}\n声明某个接口类型\nvar T name\n接口赋值\n​\tx = a\nT = new(NokiaPhone)\nGO方法有自动解引，是传值还是引用以方法为准\n使用接口\nT.FuncName\n任意类型都被认为实现了空接口\n接口方法最好不要超过三个\n每个接口变量在内存中占据两个字长：\n一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针\n信道 声明一个信道(双向)\nvar a chan int\n信道初始化\na = make(chan int)\n简洁声明初始化\na := make(chan int)\n有10个缓冲的信道\na := make(chan int, 10)\n// 读取信道 a\ndata := \u0026lt;- a\n// 写入信道 a\na \u0026lt;- data\n单向信道\n只读 var pipline = make(chan int)\ntype Receiver = \u0026lt;-chan int\nvar receiver Receiver = pipline\n只写 var pipline = make(chan int)\ntype Sender = chan\u0026lt;- int\nvar sender Sender = pipline\n关闭 close(pipline)\n站位符 点击这里\n 下期预告：用Go实现爬虫\n","date":"2022-03-03T00:00:00Z","image":"https://pic1.zhimg.com/v2-d8710566b4f7ce6096f92c943454503d_1440w.jpg?source=172ae18b","permalink":"https://halo233.github.io/p/go%E7%B1%BB%E5%9E%8B/","title":"Go类型"},{"content":"并发和并行的区别  比如你正在吃饭，这个时候突然手机来了电话，电话在响，你还是在吃饭，吃完了饭才开始接电话\n这就是不支持并发和并行\n  你还是在吃饭，这时候突然来了电话，电话在响，你接了电话，接着吃饭\n这就是并发\n  身为干饭人的你还是在吃饭，这时候又是电话，电话在响，你边接电话边吃饭\n这就是并行\n 并发主要是单核处理器，处理多个任务的时候，在这些任务快速切换来处理任务，每个任务在时间上不重合\n并行主要是多核处理器，处理多个任务的时候，这些任务同时处理，任务在时间上有重合\n关于处理器的个数和核心这篇大佬的 文章 解释的很清楚\n","date":"2022-02-25T00:00:00Z","permalink":"https://halo233.github.io/p/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C/","title":"并发和并行"},{"content":"第一步 在博客仓库里面添加CNAME文件（无后缀名） 内容为你的二级域名比如\tto.fucg.top\n第二步 到二级域名的管理地址添加记录值 选择CNAME 记录值为你的GitHub博客地址\n比如 myname.github.io. 其中的 最后的 . 必须添加，我也不知道为啥\n第三步 等待片刻\n","date":"2022-02-21T00:00:00Z","permalink":"https://halo233.github.io/p/githubpage%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/","title":"GitHubPage绑定二级域名"},{"content":"今天心血来潮把博客主题换了，话说stack真的好看\n本来以为要批量改页眉，居然可以通用！\n保留作者信息 按照我以前的习惯一般都是毫不留情地删除不需要的信息，但是这次我没有。\n因为这款主题真的好，应该被推广。\n之前小游大佬写了一款主题后来被别人盗了，气得他直接申请软著。我们也看到了这种事情的后果。\n作者辛辛苦苦写的主题，然后就这样直接盗用，还他妈名字都不给别人留。\n所以以后即便用开源的东西，也要在里面注明作者，尊重开源，表达敬意！\n上手stack 里面有一个推特的啥配置文件要删除，我第一次也是打不到头脑，\n好在哔哩哔哩刚刚好有教程，建议3倍播放 视频教程\n","date":"2022-02-20T00:00:00Z","image":"https://browser9.qhimg.com/bdm/1000_618_80/t010448c46c1ecf7cab.jpg","permalink":"https://halo233.github.io/p/stack%E4%B8%BB%E9%A2%98/","title":"stack主题"},{"content":"主要说说C的多文件模块编程，还有一点CGO C的模块编程 主要是把函数封装成库，比如现在的C文件下有main函数，有A函数，有B函数，有C函数，都返回 int 类型\n一般文件小的写法是\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //这里叫方法一吧 //其余库就不写了 //申明函数 int A(); int B(); int C(); int main() int A(){ ... } int B(){ ... } int C(){ ... }   或者为了避免声明这样写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  //这里叫方法二吧 //其余库就不写了 int A(){ ... } int B(){ ... } int C(){ ... } int main()   显然上面不够简洁，其实我们可以把函数ABC整合到一个库里面，库名就叫mycode好了\n1 2 3 4 5 6 7 8 9 10 11 12 13  //创建文件\tmycode.h //mycode.h\t里面包含的主要是那些函数的声明，也可以直接是函数 //但是为了简洁，api化，建议不要在mucode.h里面写函数 //A的函数说明 int A(); //B的函数说明 int B(); //C的函数说明 int C();   然后写入具体函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  //创建文件 mycode.c //#include\u0026lt;stdio.h\u0026gt;\t这些实现ABC功能的头文件必须存在 //直接写函数，不用再申明 int A(){ ... } int B(){ ... } int C(){ ... }   目录结构\n1 2 3  main.c mycode.h mycode.c   此时mian.c\n1 2 3 4 5 6  #inclde\u0026#34;mycode.h\u0026#34;\t//一般自己的库用 \u0026#34; \u0026#34; int main(){ A...\t//直接用库里面的函数 //是不是简洁了不少 }   关于我对这种方式的理解 mycode.h 和 mycode.c 其实就是 分别代替了 函数的声明的位置 和 函数的实现位置\n为什么说位置，因为你在mycode.h里面写函数\t就相当于方法二\n说说CGO 在GO里面调用C语言，主要是用于解决部分代码速度问题，还有就是继承C半个世纪的生态\n还是用上面的mycode库\n1 2 3 4  目录结构 mycode.h mucode.c main.go   1 2 3 4 5 6 7 8  package main //#include\u0026#34;mycode.h\u0026#34;\t这里也可以单个函数直接写 import \u0026#34;C\u0026#34; func main(){ C.A()\t//这样就调用了A函数  //刚入门还不太明白如何手动释放内存，这个时候A占用内存还没释放 }   采用上面的目录结构运行mian.go\n1  go run .\t  编译main.go\n1  go build   还有很多东西不明白，今天就算是体验了一下CGO吧，还有回顾了一下C的模块化编程\n","date":"2022-02-18T00:00:00Z","permalink":"https://halo233.github.io/p/%E5%A4%9A%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B/","title":"多文件模块编程"},{"content":"说好先安静一下，但是我就是控制不住自己 说说今天的事吧，今天体验了一下Kali的arp欺骗，亲测可用在B站无意看到的\n体验了一下断网\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  kali切换源到国内\tdeb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 然后下载\tapt-get install dsniff 查看自己ip\tifconfig\t这里用me表示自己ip 用h表示网关ip 扫描同一网段的用户ip fping -g me/24 得到一系列用户ip 这里用you表示你要断网的ip 欺骗you我是h arpspoof -i -t eth0 you h 结果还真把我手机给断网了，无法访问百度，但是视频可以加载只是部分被断网了   ARP高级玩法\n 渗透图片 渗透密码  有空再体验一下吧！我只知道现在很浮躁，状态也不是很好，不适合学习！\n 还是今天无意看到的一篇文章\nsleep（0） 有什么用 可能不少人都会和我一样第一感觉就是没用的废语句，但是他大有用处\nlinux和Windows的cpu控制分配方式不一样\nlinux是定时分配 什么意思，定时分配，就是每个程序可以霸占CPU的时间是一样的，\n给人的感觉就是系统才是老大\n当一个程序在规定时间以内超前完成任务，他告诉CPU自己已经完成任务，系统就会安排下一个程序\n当程序在规定时间内还是没有完成任务，系统会强制结束CPU给他的霸占，安排下一个程序\nwindows是强入式分配 这里对CPU的霸占是，系统会根据程序对CPU使用的时间等等因素做一个排序，对排序高的就先使用CPU\n但是程序对CPU的霸占自己主动让出CPU才会空出，这个时候系统会重新排名一下使用CPU的程序\n让下一个排序最高的程序使用CPU，\n给人的感觉是排序高的程序才是老大\n而如果一个程序长时间霸占CPU，这时候系统就会把这个程序挂起，再排名，再把CPU让给下一个排名高的程序\nsleep（0）就可以就是挂起程序0秒，引发系统重新排名，\n如果排名依然很高，就接着使用CPU，\n如果排名低，就会让位CPU\n 元宵节快乐！ 共产党今天送了我家一床铺盖，感觉好温暖。\n我励志以后也要当一名党员，因为共产党员是给别人带来温暖的人\n","date":"2022-02-15T00:00:00Z","permalink":"https://halo233.github.io/p/kali%E6%96%AD%E7%BD%91%E5%A4%A7%E6%B3%95/","title":"kali断网大法"},{"content":"说说今天的事吧 第一件事就是 我搭建了一个免流服务器，用的是别人的脚本\n1 2  yum -y install wget wget --no-check-certificate https://startml.net/bash/pj.sh \u0026amp;\u0026amp; bash pj.sh   系统是centos7而centos8会乱码，直接把服务器的500G流量自己用，爽歪歪！\n第二件事 一个同学找我谈合作，估计是看到我的服务器改造为免流服务器了，觉得我很厉害吧。\n他的想法就是，自己有一套方便校园的小程序，小程序内部包含：跑腿，表白等等业务\n虽然我知道自己要实现紫罗兰留言板必然会学这些，但是我不想平白无故地给别人打工\n虽然说他的想法很棒，但是我以前也有想过这些。\n白白给别人打工，说到盈利方式，盈利分配就回避，这不是明显找我当免费劳动力吗？\n第三件事 拥护开源，GitHub真的好用，里面不仅有各种各样的开源项目\n而且在我操作失误不小心删除我的博客的时候，他能回滚，一下就回到还算正常的时候了，\n虽然访问速度慢，但是配上别人的加速器简直无敌，还有手机版的可以查看最新的消息\n第四件事  人不很，事不成\n 给爷记到DNA里面去，今天加回了q（光遇好友），一顿尬聊。\n以后做事一定不能磨磨唧唧的，太容易多愁善感了，这样容易失败\n 感想  等我紫罗兰留言板做好后就再去看一次《紫罗兰永恒花园》，每次我想放弃的时候，我都会想到自己曾在书上写过一定要写一个GO公益网站，我记得当时我很清醒，虽然现在有一点迷茫了，但是我相信自己当时清醒时的判断 我现在很浮躁，无论要多久，我都想先静下来后在做事，无论要静多久，无论静的代价，都要先静下来，找到方向后再出发 大胆一点，选择新事物，就像高中同学有几个选择日语一样，后来不是也很好吗，大胆选择 还有就是这辈子都不要在经历毕业给别人高举双手鼓掌了，我真的好心痛当时的自己！  ","date":"2022-02-13T00:00:00Z","permalink":"https://halo233.github.io/p/%E4%BB%8E%E6%96%B0%E6%95%B4%E7%90%86%E5%86%8D%E5%87%BA%E5%8F%91/","title":"从新整理，再出发"},{"content":"hugo来生成博客确实爽，快得一批。\n我想把我的博客上传到网上，这样就可以在任意设备访问自己的博客。\n最后我选择了Github，香得一批。\n但是每次都在Github网页上手动上传文件，有一亿点麻烦。\n所以就有了今天的Git初始化然后Git上传静态博客\n看了很多别人的Git上传，还是这篇讲的好，下面开始我的表演\n GitHub部分  注册一个Github账号（英文不好怪自己） 创建一个仓库，注意仓库名字应该是 your name github.io 比如 halo233.github.io 还有就是不要勾选readme 然后在设置里面找到 SSH ，新建一个，名字随意，kay的话先不填 等Git生成好了再填  Git部分 下载 - 安装 - 环境变量 这里就不说了\n一切就绪后输入下方命令\n1 2  git config --global user.name \u0026#34;your name\u0026#34; git config --global user.email \u0026#34;your@email.com\u0026#34;   然后创建sshkay\n1 2  ssh-keygen -t rsa -C \u0026#34;your@email.com\u0026#34; //输入后一路确认   找到本地用户文件夹.ssh的文件夹，里面包含id_rsa和id_rsa.pub两个文件\n然后用记事本打开id_rsa.pub，全选,复制\n这个就是Github需要的Kay然后回去填写\n基本配置就好了\n然后就是Git的使用 1 2 3 4 5 6  git init git add . //添加该目录下所有文件 git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/halo233/test.git //新建创库会有提示地址 git push -u origin main   补充 如果初始化的时候添加了readme\n1 2 3  出现了 error: failed to push some refsto‘远程仓库地址’ 你可以输入 git pull --rebase origin main 再push一下   原文链接点这里\n","date":"2022-02-12T00:00:00Z","permalink":"https://halo233.github.io/p/git%E9%85%8D%E7%BD%AEgithub/","title":"Git配置Github"},{"content":"之前在学校吃了几次链表的亏，后来狠心把链表学了 C语言作为自己的学习语言，Go语言和Java作为自己的开发语言有空再学学js，这学期要把紫罗兰留言板雏形整出来\n话不多说上单向链表的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164  #include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;typedef struct person { int num; struct person *next }link; link * ap(link *head); //按顺序接入链表 void display(link *head);//输出链表 void del(link *head);//删除所有节点 link * de(link *head,int n);//删除链表中指定节点 link * add(link *head, int n);//在链表中添加一个节点，假设链表已经按升序排好了  int main() { link *head =NULL; for(int i=0;i\u0026lt;4;i++) { head = ap(head); } display(head); int n; printf(\u0026#34;\\n你要删除的数字\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); head = de(head,n); display(head); printf(\u0026#34;\\n你要添加的数字\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); head = add(head,n); display(head); del(head); return 0; } link *ap(link *head) { link *p=NULL,*pr =head; p = (link *) malloc(sizeof(link)); if(p==NULL){ printf(\u0026#34;分配内存失败！\u0026#34;); exit(0); } if (head == NULL) { head = p; }else{ while(pr-\u0026gt;next != NULL) { pr = pr-\u0026gt;next; } pr-\u0026gt;next = p; } int num; scanf(\u0026#34;%d\u0026#34;,\u0026amp;num); p-\u0026gt;num = num; p-\u0026gt;next = NULL; return head; } void display(link *head) { link *p = head; while(p != NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;num); p = p-\u0026gt;next; } } void del(link *head) { link *pr = NULL,*p =head; while(p != NULL) { pr = p; p = p-\u0026gt; next; free(pr); } //这里没有问题 } link* de(link *head,int n) { link *p = head,*pr = NULL; if(head==NULL) { printf(\u0026#34;这是一个空链表\\n\u0026#34;); return head; } while(p-\u0026gt;num != n \u0026amp;\u0026amp; p-\u0026gt;next != NULL) { pr = p; p = p-\u0026gt;next; } if(p-\u0026gt;num==n) { if (p == head) { head = p-\u0026gt; next; } else{ pr-\u0026gt;next = p -\u0026gt;next; } free(p); } else{ printf(\u0026#34;没有查找到该数!\\n\u0026#34;); } return head; } link * add(link * head,int n) { link *pr = head,*p = NULL; link *temp =NULL; p = (link *)malloc(sizeof(link)); if (p == NULL) { printf (\u0026#34;分配内存失败！\\n\u0026#34;) return head; } p -\u0026gt;num = n; p -\u0026gt;next = NULL; while(pr-\u0026gt;num \u0026lt; n \u0026amp;\u0026amp; pr -\u0026gt; next != NULL) { temp = pr; pr = pr -\u0026gt; next; } if(pr == head) { p-\u0026gt;next = pr; head = p; return head; //在头上  } if(pr-\u0026gt;num \u0026gt;= n) { //在中间  temp -\u0026gt; next = p; p-\u0026gt;next = pr; }else{ //在尾巴上了  pr-\u0026gt;next = p; } return head; }   今天又复习了一下，用Go复刻了一个，我承认复习学过的东西很重要，MD老子又忘记该怎么写了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144  package main import \u0026#34;fmt\u0026#34; type node struct { n int next *node } //apone 在末尾加一个节点 func (head *node) apone() *node { p := new(node) pr := head if p == nil { fmt.Println(\u0026#34;分配内存错误\u0026#34;) return head } if head == nil { head = p } else { for pr.next != nil { pr = pr.next } pr.next = p } // 修改添加的节点的数据 \tvar n int fmt.Printf(\u0026#34;请输入数字\u0026#34;) fmt.Scan(\u0026amp;n) p.n = n return head } func (head *node) display() { p := head for p != nil { fmt.Printf(\u0026#34;%d \u0026#34;, p.n) p = p.next } fmt.Println(\u0026#34;输出完毕\u0026#34;) } func (head *node) delone(n int) *node { var pr *node p := head for p.n != n \u0026amp;\u0026amp; p.next != nil { pr = p p = p.next } if p.n == n { if p == head { head = p.next } else { pr.next = p.next } } else { fmt.Println(\u0026#34;没有查找到该数\u0026#34;) } return head } func (head *node) delall() { p := head pr := p for p != nil { pr = p p = p.next pr.next = nil } //手动释放头节点，虽然p没有指向这个节点但是head还指向它的 \t//GC回收标准是内存没有指针指向  //但是head为局部变量指针，所以这里的head是一个副本，在main函数中还是有一个不为 nil 的 head \thead = nil//无用代码 } //addone 假设节点是按升序排号了的，我们在按升序插入一个节点 func (head *node) addone(n int) *node { var p, pr, temp *node temp = new(node) if temp == nil { fmt.Println(\u0026#34;分配内存失败\u0026#34;) return head } temp.n = n p = head if head == nil { return head } for p.n \u0026lt; n \u0026amp;\u0026amp; p.next != nil { pr = p p = p.next } if p == head { temp.next = head head = temp return head } if p.n \u0026gt;= n { pr.next = temp temp.next = p } else { p.next = temp } return head } func main() { var head *node for i := 0; i \u0026lt; 7; i++ { head = head.apone() } head.display() var n int fmt.Println(\u0026#34;输入一个你想删除的数字\u0026#34;) fmt.Scan(\u0026amp;n) head = head.delone(n) head.display() fmt.Println(\u0026#34;输入一个你想添加的数字\u0026#34;) fmt.Scan(\u0026amp;n) head = head.addone(n) head.display() head.delall() head.display() }   ","date":"2022-02-11T00:00:00Z","permalink":"https://halo233.github.io/p/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/","title":"单向链表"},{"content":"整理之前的文档找到的进度条 之前模仿某位大佬写的，今天正好复刻一次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  //实现自己的Bar package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;time\u0026#34; ) type Bar struct { cur int64 total int64 percent int64 graph string rate string } func (r *Bar) NewwBar(cur, total int64) { if cur \u0026gt;= total { log.Fatal(\u0026#34;cur \u0026gt;= total\u0026#34;) } r.cur = cur r.total = total r.percent = r.GetPercent() r.graph = \u0026#34;#\u0026#34; } func (r *Bar) GetPercent() int64 { return int64(float64(r.cur) / float64(r.total) * 100) } func (r *Bar) DisPlay(cur int64) { if cur \u0026lt; r.cur { log.Fatal(\u0026#34;数据载入错误\u0026#34;) } r.cur = cur r.percent = r.GetPercent() r.rate = \u0026#34;\u0026#34; for i := 0; int64(i) \u0026lt;= r.percent; i += 2 { r.rate += r.graph } fmt.Printf(\u0026#34;\\r%-50s %d%%100 %d/%d\u0026#34;, r.rate, r.percent, r.cur, r.total) } func main() { var bar Bar var cur, total int64 = 0, 100 bar.NewwBar(cur, total) for cur \u0026lt;= total { bar.DisPlay(cur) time.Sleep(1 * time.Millisecond) cur++ } }   ","date":"2022-02-10T10:23:09+08:00","permalink":"https://halo233.github.io/p/go%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%A4%8D%E5%88%BB/","title":"Go进度条复刻"},{"content":"整理一些Go包   goyaml\n  其中goyaml-struct-tag 标签是  ``符号,而不是 ''符号，正确的符号在键盘左上方\n  1 2 3 4 5 6  goyaml使用 data, _ := ioutil.ReadFile(\u0026#34;./fd.yaml\u0026#34;)\terr := yaml.Unmarshal(data, \u0026amp;myfd)\t//data是切片 myfd 是对应的全局结构体 必须有对应的tag //比如 在 fd.yaml中有\tname : 你大爷 //结构体中得有\tname string `yaml:\u0026#34;name\u0026#34;`       gomail\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  gomail的使用 //构建信件内容 msger := NewMessage() msger.SetHeader(\u0026#34;From\u0026#34;,sendmailaddress) msger.SetHeader(\u0026#34;To\u0026#34;,mailaddress) msger.SetAddressHeader(\u0026#34;Cc\u0026#34;,mailaddress,who)//抄送给who  msger.SetHeader(\u0026#34;Subject\u0026#34;,subject) msger.SetBody(\u0026#34;text/html\u0026#34;,content) msger.Attach(\u0026#34;./xxx.png\u0026#34;) //准备信件发送 d := gomail.NewDialer(\u0026#34;smtp.126.com\u0026#34;, 25, \u0026#34;xxx@126.com\u0026#34;, \u0026#34;Your Password kay\u0026#34;) if err := d.DialAndSend(m); err != nil { //发送失败  }        gomod管理\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  package main 可以拆分，且包名与文件名无关 比如有一下两个文件 A.go package main import \u0026#34;fmt\u0026#34; func main(){ a() b() } func a(){ fmt.Println(\u0026#34;我在A文件的main包里面\u0026#34;) } B.go package main func b(){ fmt.Println(\u0026#34;我在B文件的main包里面\u0026#34;) } 如何运行完整的main包？ 在终端输入 go run A.go B.go 如果是Linux下直接 go run *.go     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  go项目的目录情况应该这样 filename\t//整个项目名称 \tmain.go go.mod go.sum //这个是go所需要的包的版本哈希值 \tA\t//A包 \tname1.go\t//所有文件内部都必须注明 package A \tname2.go\t//文件名称无所谓 \tname3.go B\t//B包 \tname1.go name2.go name3.go 在 mian.go 中调用包应当这样写 import \u0026#34;filename/A\u0026#34; 以前的版本可以 \u0026#34;./A\u0026#34; 但是现在报错 如果要把 A包 归纳到 mian 包 就这样写 import .\u0026#34;filename/A\u0026#34;       ","date":"2022-02-09T17:10:09+08:00","permalink":"https://halo233.github.io/p/%E6%95%B4%E7%90%86%E4%B8%80%E4%BA%9Bgo%E5%8C%85/","title":"整理一些Go包"},{"content":"Lua Lua解释器下载后解压发现并不是lua.exe\n而是lua54.exe\n最简单有效的办法是把 lua54.exe 重命名为 lua.exe 然后把该目录添加到环境变量\nGO Go的编译器下载后一路默认\t不过个人觉得还是放在 C:\\go 目录下最好\n但是由于是在国内很多东西GO无法使用\n代理\t可以解决访问github的包的问题还有和vscode插件下载的问题\n七牛代理\t在终端输入\n1 2  go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct   环境变量 刚学编程不知道这个怎么设置，走了很多路，特别记录一下\n打开\t控制面板\\系统和安全\\系统\\高级系统设置\\环境变量\n点击\tpath\t后再点击编辑再点击添加\n地址就填写你的编译器或者解释器的\tbin目录\t比如\tC:\\go\\bin\n","date":"2022-02-07T18:16:09+08:00","permalink":"https://halo233.github.io/p/windows%E4%B8%8Ago%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8Clua%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85/","title":"Windows上go编译器和lua解释器的安装"},{"content":"博客建设 博客使用 hugo 生成 ，用 typora 编写文档\n主题使用的是 hermit 我选了一个下午，最后还是决定使用这款简约的主题 不是有些主题无法运行\n主题修改部分\n 去掉了那个由啥构建的提示 去掉了社交链接  还有就是想修改但是不知道在哪里修改的\n 网站图标\t（20220212 找到了但是不好改） 时间 tag  建设感想 小生第一次开始使用博客还是蛮激动的，特别写下这篇博文记录一下\n有空再整理一下之前的文章\nhermit主题的坑 20220212\n上线到GitHub，发现这个东西，meun 不好用，动不动就404\n后来无意发现在配置文件里面把按钮url修改为 posts/todo/ 才可以正常用\n等下我再结合Git 写个批量处理脚本 自动 push 同步博客 美滋滋！\n","date":"2022-01-01T00:00:00Z","permalink":"https://halo233.github.io/p/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","title":"第一篇博文"}]